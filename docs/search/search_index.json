{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello Cloud Hello and welcome! This project contains examples of \"hello world\" automation deployed to major cloud providers. While each major cloud provider offers similar tutorials, they tend to focus almost entirely on manual website interactions to setup and execute each tutorial. Most engineers will need to figure out how to automate these tasks for consistent execution by a team of engineers as well as by their DevOps pipeline continuous integration and deployment workflows. Automation and consistency is a goal of this project while leveraging the unique capabilities each cloud has to offer. Resources Make a contribution Learn about the DevOps pipeline See where things are headed on the roadmap Projects .NET Java with SpringBoot NodeJS with ExpressJS Start contributing!","title":"Home"},{"location":"#hello-cloud","text":"Hello and welcome! This project contains examples of \"hello world\" automation deployed to major cloud providers. While each major cloud provider offers similar tutorials, they tend to focus almost entirely on manual website interactions to setup and execute each tutorial. Most engineers will need to figure out how to automate these tasks for consistent execution by a team of engineers as well as by their DevOps pipeline continuous integration and deployment workflows. Automation and consistency is a goal of this project while leveraging the unique capabilities each cloud has to offer. Resources Make a contribution Learn about the DevOps pipeline See where things are headed on the roadmap","title":"Hello Cloud"},{"location":"#projects","text":".NET Java with SpringBoot NodeJS with ExpressJS Start contributing!","title":"Projects"},{"location":"comments/","text":"Comments Welcome to \"hello-cloud\". We try our best to make sure that the discussions on our articles are the troll, spam and abuse free but we're not omnipresent. The comment section can be a great place for interaction with readers, writers and even for spawning stimulating conversation \u2013 it can be a great place for all of us! To ensure that we all have a great experience, please make sure to stick to the following guidelines: The Rules Be polite. Do not be rude to anyone and respect others. If something you would say would get you bottled on the head offline, please do not say it here. Remember there is a person behind the screen and that your words affect people. Do not troll. We appreciate and welcome criticism towards writers here, but comments that add no value to the discussion or that are merely insulting would be deleted without exception. Spam? Goodbye! We understand that you may make thousands of dollars spewing garbage, however, we are not interested. Please refrain from posting or we will give you a hand and show both you and your post out the door. To put it in a simple sentence, our guidelines boil down to \"Don't be a jerk\". If you don't follow any of these guidelines, not only will our moderators remove the comment but we may also ban you from participating in the community. If you find any comments which violate our guidelines, please make sure to 'flag' or 'mark as spam' \u2013 our moderators highly appreciate your support! Happy commenting!","title":"Comments"},{"location":"comments/#comments","text":"Welcome to \"hello-cloud\". We try our best to make sure that the discussions on our articles are the troll, spam and abuse free but we're not omnipresent. The comment section can be a great place for interaction with readers, writers and even for spawning stimulating conversation \u2013 it can be a great place for all of us! To ensure that we all have a great experience, please make sure to stick to the following guidelines: The Rules Be polite. Do not be rude to anyone and respect others. If something you would say would get you bottled on the head offline, please do not say it here. Remember there is a person behind the screen and that your words affect people. Do not troll. We appreciate and welcome criticism towards writers here, but comments that add no value to the discussion or that are merely insulting would be deleted without exception. Spam? Goodbye! We understand that you may make thousands of dollars spewing garbage, however, we are not interested. Please refrain from posting or we will give you a hand and show both you and your post out the door. To put it in a simple sentence, our guidelines boil down to \"Don't be a jerk\". If you don't follow any of these guidelines, not only will our moderators remove the comment but we may also ban you from participating in the community. If you find any comments which violate our guidelines, please make sure to 'flag' or 'mark as spam' \u2013 our moderators highly appreciate your support! Happy commenting!","title":"Comments"},{"location":"contribute/","text":"Contributing Welcome and we are glad you are interested in contributing! Adding a new project Is your favorite language and/or framework to build a website or web service missing from this project? What great ideas to you have to demonstrate getting systems to the cloud? A working program 1. The 'Hello World' program Check if the idea is already on the roadmap or has already been submitted as an issue . Submit an issue that describes your idea to start a discussion. Fork this project and clone it to your local system. Review the \"Development\" steps below. Review one of the existing projects for similarities to your idea. Create a new directory for your source code (e.g. \"./src/services/[language/framework]\" for web services or \"./src/apps/[language/framework]\" for web applications). Add a basic \"hello world\" example using the language and framework of choice. Commit small, working changes regularly and please use \"conventional commit messages\" . You can see existing examples of commit messages . Automate the developer tasks by creating a new \"./makefile\" in your project, copy command targets from an existing \"./makefile\" from another project and customize the commands to work with your language and framework. Ignore any deployment commands for now and also ignore command targets you are not ready or not sure how to implement. Commit your changes. Add the path to your project in the root \"./makefile\" in the space-separated \"project_dirs\" variable list. This will enable developers to build and run all projects at the same time, including yours. Commit your changes. Submit a \"draft pull request\" back to this project. We will start a discussion on the proposed implementation. Please be open to making any suggested changes. 2. Containers Once you have a basic \"hello world\" example working, it's time to containerize your system, so that it can be executed by any Open Container Initiative-compatible runtime. Review an existing \"./makefile\" from another project and customize your project's commands to work with docker , docker-compose and podman . Hopefully, a base docker image will already exist to mount and execute your application (e.g. node ). If so, use this as your base. If not, consider choosing Alpine Linux , Debian , or Ubuntu for your base image. Create a \"Dockerfile\" and test your container locally. Commit your changes. Update your existing Pull Request so that we can discuss the container work. 3. Writing documentation Once you have a working container, it's time to start documenting your project. Copy and paste an existing project's markdown file from \"./src/docs/\" (e.g. ./src/docs/services/nodejs-expressjs.md). Review and edit the sections to match, customizing links and commands to match your project's needs. Delete any cloud deployment sections at this time. Commit your changes. Add links to your project documentation in \"./mkdocs.yml\" as well as \"./src/docs/index.md\" (both are under \"Projects\"). Commit your changes. Update your existing Pull Request so that we can discuss the documentation. 4. Integrating a DevOps pipeline Documentation for all projects will be automatically built through the \"documentation\" pipeline . However, we need to build and publish your project's docker container. Copy and paste an existing project's GitHub Actions pipeline workflow \".yml\" configuration from \"./.github/workflows/\". Customize the names and paths to match your project. It will not be possible to test this workflow. Commit your changes. Update your existing Pull Request so that we can discuss the workflow. 5. Finalize PR Although your project has not even been deployed to a major cloud provider yet, the basic foundation now exists to integrate cloud automation tasks. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch, your project container will be built and published, and your project will be added to the public documentation. This now provides others with a chance to build on top of your project too. Cloud deployments Once we have a working, containerized program, we can begin cloud deployment automation tasks. 1. Pick just one cloud Pick one of the major cloud providers that you will target a deployment for (e.g. AWS, Azure, GCP, or Heroku). If your cloud provider is not in this list, please first propose a new one by submitting an issue and we can discuss the proposal. Please understand that your request could be denied. You will need an account that may incur costs when testing your cloud deployment. Most \"hello world\" implementations are free or very cheap on major cloud providers, especially if you focus on automating destruction of cloud resources and destroy them immediately after creating them and testing for success. Review an existing project's cloud deployment documentation. Review an existing project's \"./makefile\" cloud deployment command targets. Begin work to add your own cloud deployment command targets to your project's \"./makefile\". Commit your changes. Begin to document the steps by copying and pasting the cloud section from an existing project and customizing as required. Commit your changes. Update your project's \"Roadmap\" section with what has been completed and possible next steps. Commit your changes. Submit another \"draft pull request\" back to this project to start the discussion on your cloud deployment tasks. Please be open to making any suggested changes. 2. Finalize PR We will work to test the cloud deployment. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch and your project's cloud deployment documentation will be updated in the public documentation. 3. Enhance, enhance, enhance As you did in the first step, you and even others may continue to enhance this great project! Development This project attempts to support a variety of developer tooling choices while maintaining a standard that everyone can test against. Prerequisites Windows users Task automation assumes a POSIX-compatible shell with Linux commands that work across most distributions and macOS. As a result, using Windows Subsystem for Linux (WSL2) is recommended with a Linux distribution like Debian, Ubuntu, or Kali Linux. You may also use Git BASH with make for Git BASH installed or cygwin with make for cygwin installed. You could also use a Linux virtual machine running on Windows Hyper-V , Oracle VirtualBox , or even using a VS Code \"devcontainer\" . Tools Avoid Global installations of gradle or maven are not needed or recommended. The Java projects use Gradle wrapper and Maven wrapper with a pinned, project-specific version to ensure version consistency across machines. Required git for source control. docker , docker-compose , or podman are required to build the documentation and production container images. Recommended GNU make is required for DevOps pipelines Continuous Integration (CI) and Deployment (CD) tasks. For consistency, this install is recommended. ( Windows users: see note above ) Optional... yarn or node are required to run NodeJS projects ( yarn is recommended ). The version of yarn is \"pinned\" in \".yarnrc\" and will be automatically selected and used by the yarn command. However, container runtimes make this installation optional. nvm can make switching between specific versions of node , npm , and npx easier across projects for a more consistent project experience across machines. The version of node is \"pinned\" in \".nvmrc\" and will be automatically selected and used by the nvm use command. However, container runtimes make this installation optional. java 11 OpenJDK is required to run Java projects. However, container runtimes make this installation optional. dotnet 6 SDK is required to run .NET projects. However, container runtimes make this installation optional. VS code may be used for an improved developer experience with support for project-specific settings, extensions, and tasks. git-town may be used for improved developer workflow. Executing tasks Task execution consistency can be critical when developing and triaging code. While many tools are supported, \"there is only one way\" for production, including the DevOps pipeline automation tasks. Local development machines and even DevOps pipeline machines have different Operating Systems, middleware tools, and configurations; they cannot be trusted to be reliable. Therefore, the \"one way\" is through containers and the default tool of choice is docker ; while this project would prefer to use a completely free and open source ecosystem like podman , docker is a well established project, virtually ubiquitous on most local and DevOps machines, and mostly free . Commands that work across all projects All automation tasks are abstracted behind make command targets. This enables task consistency across projects and tooling. You may run most commands using your choice of podman , docker , docker-compose , gradle or maven (for Java projects), yarn or node / npm (for Node projects), or dotnet (for .NET projects) by adding a \"dev_tool\" parameter to the make command, where the value of the parameter matches your preferred tool (e.g. make install dev_tool=yarn ; make start dev_tool=podman ; make run dev_tool=dotnet ). However, docker is recommended as the default \"dev_tool\", since it is also used by DevOps pipeline tasks for production build, test, and deploy. Clone the repository with the command git clone --depth=1 https://github.com/ericis/hello-cloud Navigate to the project in a terminal or open your favorite editor Build the project with the command make or make install ( make build will also work) Test the system with the command make check ( make test will also work) Start the system with the command make start ( make run , make up and make serve will also work) Stop the system with the default command make stop ( make down will also work). If you use an alternative tool running as a foreground process (e.g. yarn start ), simply kill the process (e.g. Cmd + . on macOS or Ctrl + C on Windows). Clean up temporary task artifacts with the command make clean ( make uninstall will also work) Using locally installed tools... If you do not wish to use make , review the commands in the \"./makefile\" and construct the appropriate command or simply try out what you expect to work. # run a NodeJS project with native commands $ npm install && npm start $ yarn && yarn start # run a Java project with native commands $ ./gradlew bootRun $ ./mvnw spring-boot:run # run a .NET Core project with native commands $ dotnet run","title":"Contribute"},{"location":"contribute/#contributing","text":"Welcome and we are glad you are interested in contributing!","title":"Contributing"},{"location":"contribute/#adding-a-new-project","text":"Is your favorite language and/or framework to build a website or web service missing from this project? What great ideas to you have to demonstrate getting systems to the cloud?","title":"Adding a new project"},{"location":"contribute/#a-working-program","text":"1. The 'Hello World' program Check if the idea is already on the roadmap or has already been submitted as an issue . Submit an issue that describes your idea to start a discussion. Fork this project and clone it to your local system. Review the \"Development\" steps below. Review one of the existing projects for similarities to your idea. Create a new directory for your source code (e.g. \"./src/services/[language/framework]\" for web services or \"./src/apps/[language/framework]\" for web applications). Add a basic \"hello world\" example using the language and framework of choice. Commit small, working changes regularly and please use \"conventional commit messages\" . You can see existing examples of commit messages . Automate the developer tasks by creating a new \"./makefile\" in your project, copy command targets from an existing \"./makefile\" from another project and customize the commands to work with your language and framework. Ignore any deployment commands for now and also ignore command targets you are not ready or not sure how to implement. Commit your changes. Add the path to your project in the root \"./makefile\" in the space-separated \"project_dirs\" variable list. This will enable developers to build and run all projects at the same time, including yours. Commit your changes. Submit a \"draft pull request\" back to this project. We will start a discussion on the proposed implementation. Please be open to making any suggested changes. 2. Containers Once you have a basic \"hello world\" example working, it's time to containerize your system, so that it can be executed by any Open Container Initiative-compatible runtime. Review an existing \"./makefile\" from another project and customize your project's commands to work with docker , docker-compose and podman . Hopefully, a base docker image will already exist to mount and execute your application (e.g. node ). If so, use this as your base. If not, consider choosing Alpine Linux , Debian , or Ubuntu for your base image. Create a \"Dockerfile\" and test your container locally. Commit your changes. Update your existing Pull Request so that we can discuss the container work. 3. Writing documentation Once you have a working container, it's time to start documenting your project. Copy and paste an existing project's markdown file from \"./src/docs/\" (e.g. ./src/docs/services/nodejs-expressjs.md). Review and edit the sections to match, customizing links and commands to match your project's needs. Delete any cloud deployment sections at this time. Commit your changes. Add links to your project documentation in \"./mkdocs.yml\" as well as \"./src/docs/index.md\" (both are under \"Projects\"). Commit your changes. Update your existing Pull Request so that we can discuss the documentation. 4. Integrating a DevOps pipeline Documentation for all projects will be automatically built through the \"documentation\" pipeline . However, we need to build and publish your project's docker container. Copy and paste an existing project's GitHub Actions pipeline workflow \".yml\" configuration from \"./.github/workflows/\". Customize the names and paths to match your project. It will not be possible to test this workflow. Commit your changes. Update your existing Pull Request so that we can discuss the workflow. 5. Finalize PR Although your project has not even been deployed to a major cloud provider yet, the basic foundation now exists to integrate cloud automation tasks. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch, your project container will be built and published, and your project will be added to the public documentation. This now provides others with a chance to build on top of your project too.","title":"A working program"},{"location":"contribute/#cloud-deployments","text":"Once we have a working, containerized program, we can begin cloud deployment automation tasks. 1. Pick just one cloud Pick one of the major cloud providers that you will target a deployment for (e.g. AWS, Azure, GCP, or Heroku). If your cloud provider is not in this list, please first propose a new one by submitting an issue and we can discuss the proposal. Please understand that your request could be denied. You will need an account that may incur costs when testing your cloud deployment. Most \"hello world\" implementations are free or very cheap on major cloud providers, especially if you focus on automating destruction of cloud resources and destroy them immediately after creating them and testing for success. Review an existing project's cloud deployment documentation. Review an existing project's \"./makefile\" cloud deployment command targets. Begin work to add your own cloud deployment command targets to your project's \"./makefile\". Commit your changes. Begin to document the steps by copying and pasting the cloud section from an existing project and customizing as required. Commit your changes. Update your project's \"Roadmap\" section with what has been completed and possible next steps. Commit your changes. Submit another \"draft pull request\" back to this project to start the discussion on your cloud deployment tasks. Please be open to making any suggested changes. 2. Finalize PR We will work to test the cloud deployment. If your PR is finalized and has been approved, we will merge your PR to the \"main\" branch and your project's cloud deployment documentation will be updated in the public documentation. 3. Enhance, enhance, enhance As you did in the first step, you and even others may continue to enhance this great project!","title":"Cloud deployments"},{"location":"contribute/#development","text":"This project attempts to support a variety of developer tooling choices while maintaining a standard that everyone can test against.","title":"Development"},{"location":"contribute/#prerequisites","text":"Windows users Task automation assumes a POSIX-compatible shell with Linux commands that work across most distributions and macOS. As a result, using Windows Subsystem for Linux (WSL2) is recommended with a Linux distribution like Debian, Ubuntu, or Kali Linux. You may also use Git BASH with make for Git BASH installed or cygwin with make for cygwin installed. You could also use a Linux virtual machine running on Windows Hyper-V , Oracle VirtualBox , or even using a VS Code \"devcontainer\" .","title":"Prerequisites"},{"location":"contribute/#tools","text":"Avoid Global installations of gradle or maven are not needed or recommended. The Java projects use Gradle wrapper and Maven wrapper with a pinned, project-specific version to ensure version consistency across machines. Required git for source control. docker , docker-compose , or podman are required to build the documentation and production container images. Recommended GNU make is required for DevOps pipelines Continuous Integration (CI) and Deployment (CD) tasks. For consistency, this install is recommended. ( Windows users: see note above ) Optional... yarn or node are required to run NodeJS projects ( yarn is recommended ). The version of yarn is \"pinned\" in \".yarnrc\" and will be automatically selected and used by the yarn command. However, container runtimes make this installation optional. nvm can make switching between specific versions of node , npm , and npx easier across projects for a more consistent project experience across machines. The version of node is \"pinned\" in \".nvmrc\" and will be automatically selected and used by the nvm use command. However, container runtimes make this installation optional. java 11 OpenJDK is required to run Java projects. However, container runtimes make this installation optional. dotnet 6 SDK is required to run .NET projects. However, container runtimes make this installation optional. VS code may be used for an improved developer experience with support for project-specific settings, extensions, and tasks. git-town may be used for improved developer workflow.","title":"Tools"},{"location":"contribute/#executing-tasks","text":"Task execution consistency can be critical when developing and triaging code. While many tools are supported, \"there is only one way\" for production, including the DevOps pipeline automation tasks. Local development machines and even DevOps pipeline machines have different Operating Systems, middleware tools, and configurations; they cannot be trusted to be reliable. Therefore, the \"one way\" is through containers and the default tool of choice is docker ; while this project would prefer to use a completely free and open source ecosystem like podman , docker is a well established project, virtually ubiquitous on most local and DevOps machines, and mostly free . Commands that work across all projects All automation tasks are abstracted behind make command targets. This enables task consistency across projects and tooling. You may run most commands using your choice of podman , docker , docker-compose , gradle or maven (for Java projects), yarn or node / npm (for Node projects), or dotnet (for .NET projects) by adding a \"dev_tool\" parameter to the make command, where the value of the parameter matches your preferred tool (e.g. make install dev_tool=yarn ; make start dev_tool=podman ; make run dev_tool=dotnet ). However, docker is recommended as the default \"dev_tool\", since it is also used by DevOps pipeline tasks for production build, test, and deploy. Clone the repository with the command git clone --depth=1 https://github.com/ericis/hello-cloud Navigate to the project in a terminal or open your favorite editor Build the project with the command make or make install ( make build will also work) Test the system with the command make check ( make test will also work) Start the system with the command make start ( make run , make up and make serve will also work) Stop the system with the default command make stop ( make down will also work). If you use an alternative tool running as a foreground process (e.g. yarn start ), simply kill the process (e.g. Cmd + . on macOS or Ctrl + C on Windows). Clean up temporary task artifacts with the command make clean ( make uninstall will also work) Using locally installed tools... If you do not wish to use make , review the commands in the \"./makefile\" and construct the appropriate command or simply try out what you expect to work. # run a NodeJS project with native commands $ npm install && npm start $ yarn && yarn start # run a Java project with native commands $ ./gradlew bootRun $ ./mvnw spring-boot:run # run a .NET Core project with native commands $ dotnet run","title":"Executing tasks"},{"location":"devops/","text":"DevOps Local development See the contributor guide for local development. Pipelines Every attempt is made to ensure that all automation tasks done by a server can also be performed by a human. So, continuous integration and deployment shares a lot of the same make tasks that a developer would execute on their local machine. The production pipeline uses GitHub Actions with the source files under \"./.github/workflows/\" . Documentation Workflow: \"./.github/workflows/documentation.yml\" Source: \"./src/docs\" Deployment(s): \"./docs\" and GitHub Pages Documentation is auto-generated using make install-docs with MkDocs , Material for MkDocs , and the \"mkdocs-material\" dockerized task runtime. The result generates the source output of everything contained in \"./docs\".","title":"DevOps"},{"location":"devops/#devops","text":"","title":" DevOps"},{"location":"devops/#local-development","text":"See the contributor guide for local development.","title":"Local development"},{"location":"devops/#pipelines","text":"Every attempt is made to ensure that all automation tasks done by a server can also be performed by a human. So, continuous integration and deployment shares a lot of the same make tasks that a developer would execute on their local machine. The production pipeline uses GitHub Actions with the source files under \"./.github/workflows/\" .","title":" Pipelines"},{"location":"devops/#documentation","text":"Workflow: \"./.github/workflows/documentation.yml\" Source: \"./src/docs\" Deployment(s): \"./docs\" and GitHub Pages Documentation is auto-generated using make install-docs with MkDocs , Material for MkDocs , and the \"mkdocs-material\" dockerized task runtime. The result generates the source output of everything contained in \"./docs\".","title":"Documentation"},{"location":"license/","text":"License Restrictive Licensing Everything in the directory \"./src/media/\" may contain restrictive licensing. See below. Creative Commons The Free Stuff Everything except \"Restrictive Licensing\" below in the project falls under \"Creative Commons Zero v1.0 Universal\"; that is, completely . You are free to use the code and documentation without concern or even attribution. Restrictive Licensing Path: \"./src/media/\" Media contained in this directory may have stricter licensing restrictions. Read the unique licensing concerns listed below... Licenses \"./icons/logo/logo.svg\" may not be redistributed and is licensed to Eric Swanson from thenounproject.com Open Source Projects This project is entirely based on open source implementations that ultimately target deployments to proprietary clouds. While there are many open source projects used throughout this project, we have received the biggest help from the following projects: MkDocs Material for MkDocs podman Java OpenSDK Java Spring .NET Core NodeJS ExpressJS GNU make Alpine Linux Debian Ubuntu","title":"License"},{"location":"license/#license","text":"Restrictive Licensing Everything in the directory \"./src/media/\" may contain restrictive licensing. See below.","title":"License"},{"location":"license/#creative-commons","text":"The Free Stuff Everything except \"Restrictive Licensing\" below in the project falls under \"Creative Commons Zero v1.0 Universal\"; that is, completely . You are free to use the code and documentation without concern or even attribution.","title":"Creative Commons"},{"location":"license/#restrictive-licensing","text":"Path: \"./src/media/\" Media contained in this directory may have stricter licensing restrictions. Read the unique licensing concerns listed below... Licenses \"./icons/logo/logo.svg\" may not be redistributed and is licensed to Eric Swanson from thenounproject.com","title":"Restrictive Licensing"},{"location":"license/#open-source","text":"Projects This project is entirely based on open source implementations that ultimately target deployments to proprietary clouds. While there are many open source projects used throughout this project, we have received the biggest help from the following projects: MkDocs Material for MkDocs podman Java OpenSDK Java Spring .NET Core NodeJS ExpressJS GNU make Alpine Linux Debian Ubuntu","title":"Open Source"},{"location":"roadmap/","text":"Roadmap See each project's documentation for their unique roadmaps (e.g. NodeJS with ExpressJS ). Started .NET Core C# service example Future Python service example Go service example Angular web example React web example Vue web example Ionic stencil web example Containerized web example(s) Completed Documentation automation wit MkDocs NodeJS with ExpressJS service example Java with SpringBoot service example Amazon Web Services cloud deployment example(s) (NodeJS with ExpressJS) Microsoft Azure cloud deployment example(s) (NodeJS with ExpressJS) Google Cloud cloud deployment example(s) (NodeJS with ExpressJS) Salesforce Heroku cloud deployment example(s) (NodeJS with ExpressJS) Containerized service example(s) (NodeJS with ExpressJS, Java with SpringBoot) GitHub Actions workflow GitHub Packages with GitHub Container Registry Developer tool choices (e.g. docker vs. docker-compose vs. podman vs. [ yarn vs. npm OR gradle vs. maven OR dotnet ])","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"See each project's documentation for their unique roadmaps (e.g. NodeJS with ExpressJS ). Started .NET Core C# service example Future Python service example Go service example Angular web example React web example Vue web example Ionic stencil web example Containerized web example(s) Completed Documentation automation wit MkDocs NodeJS with ExpressJS service example Java with SpringBoot service example Amazon Web Services cloud deployment example(s) (NodeJS with ExpressJS) Microsoft Azure cloud deployment example(s) (NodeJS with ExpressJS) Google Cloud cloud deployment example(s) (NodeJS with ExpressJS) Salesforce Heroku cloud deployment example(s) (NodeJS with ExpressJS) Containerized service example(s) (NodeJS with ExpressJS, Java with SpringBoot) GitHub Actions workflow GitHub Packages with GitHub Container Registry Developer tool choices (e.g. docker vs. docker-compose vs. podman vs. [ yarn vs. npm OR gradle vs. maven OR dotnet ])","title":"Roadmap"},{"location":"services/dotnet/","text":"Service: .NET Core Container: hello-cloud/our-hello-dotnet-webapi Source: ./src/services/dotnet/webapi/ Runtime: .NET Core Language: C# Framework: ASP.NET Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/dotnet_webapi.yml\" Source: \"./src/services/dotnet/webapi\" Deployment(s): \"hello-cloud/our-hello-dotnet-webapi\" docker container, Amazon Web Services AppRunner, Microsoft Azure App Service, Google Cloud App Engine Deployments Docker Run as a container The \"hello-cloud/our-hello-dotnet-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:5124/ . docker run \\ --name = our-hello-dotnet-webapi \\ --detach \\ --publish = 5124 :80 \\ ghcr.io/ericis/hello-cloud/our-hello-dotnet-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-dotnet-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|gcloud Install (deploy) with the command make cloud-install cloud=aws|gcloud Get the applicaiton logs with the command make cloud-logs cloud=aws|gcloud Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|gcloud Amazon Web Services (AWS) Prerequisites An AWS account ( this project worked with free infrastructure at the time of its creation ) aws CLI dotnet \"aws.deploy.cli\" tool Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ). Run the command make aws-init to verify your tool installations. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs . Help wanted to automate this command. Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account ( this project worked with free infrastructure at the time of its creation ) az CLI dotnet 6 SDK Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. Roadmap Started Start contributing! Future Deploy to cloud Platform-as-a-Service (PaaS) \"heroku\" Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"azure\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( dotnet ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" requires a container \"azure\" \"gcloud\" requires a container Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"gcloud\"","title":".NET"},{"location":"services/dotnet/#service-net-core","text":"Container: hello-cloud/our-hello-dotnet-webapi Source: ./src/services/dotnet/webapi/ Runtime: .NET Core Language: C# Framework: ASP.NET","title":"Service: .NET Core"},{"location":"services/dotnet/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/dotnet/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/dotnet_webapi.yml\" Source: \"./src/services/dotnet/webapi\" Deployment(s): \"hello-cloud/our-hello-dotnet-webapi\" docker container, Amazon Web Services AppRunner, Microsoft Azure App Service, Google Cloud App Engine","title":" DevOps"},{"location":"services/dotnet/#deployments","text":"","title":"Deployments"},{"location":"services/dotnet/#docker","text":"Run as a container The \"hello-cloud/our-hello-dotnet-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:5124/ . docker run \\ --name = our-hello-dotnet-webapi \\ --detach \\ --publish = 5124 :80 \\ ghcr.io/ericis/hello-cloud/our-hello-dotnet-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-dotnet-webapi\" image .","title":" Docker"},{"location":"services/dotnet/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|gcloud Install (deploy) with the command make cloud-install cloud=aws|gcloud Get the applicaiton logs with the command make cloud-logs cloud=aws|gcloud Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|gcloud","title":"Multi-cloud"},{"location":"services/dotnet/#amazon-web-services-aws","text":"Prerequisites An AWS account ( this project worked with free infrastructure at the time of its creation ) aws CLI dotnet \"aws.deploy.cli\" tool Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ). Run the command make aws-init to verify your tool installations. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs . Help wanted to automate this command. Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/dotnet/#microsoft-azure","text":"Prerequisites An Azure account ( this project worked with free infrastructure at the time of its creation ) az CLI dotnet 6 SDK Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":" Microsoft Azure"},{"location":"services/dotnet/#google-cloud","text":"Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/dotnet/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":" Google Cloud"},{"location":"services/dotnet/#roadmap","text":"Started Start contributing! Future Deploy to cloud Platform-as-a-Service (PaaS) \"heroku\" Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"azure\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( dotnet ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" requires a container \"azure\" \"gcloud\" requires a container Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"gcloud\"","title":"Roadmap"},{"location":"services/java-springboot/","text":"Service: Java with SpringBoot Container: \"hello-cloud/our-hello-java-springboot-webapi\" Source: ./src/services/java/springboot/webapi/ Runtime: OpenJDK Language: Java Framework: SpringBoot Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/java_springboot_webapi.yml\" Source: \"./src/services/java/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-java-springboot-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku Deployments Docker Run as a container The \"hello-cloud/our-hello-java-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:8080/ . docker run \\ --name = our-hello-java-springboot-webapi \\ --detach \\ --publish = 8080 :8080 \\ ghcr.io/ericis/hello-cloud/our-hello-java-springboot-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-java-springboot-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites An AWS account ( this project worked with free infrastructure at the time of its creation ) eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account ( this project worked with free infrastructure at the time of its creation ) az CLI java 11 OpenJDK (required to execute ./mvnw commands) Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Plugins Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Java SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. SalesForce Heroku Prerequisites A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Java buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall Roadmap Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"Java with SpringBoot"},{"location":"services/java-springboot/#service-java-with-springboot","text":"Container: \"hello-cloud/our-hello-java-springboot-webapi\" Source: ./src/services/java/springboot/webapi/ Runtime: OpenJDK Language: Java Framework: SpringBoot","title":"Service: Java with SpringBoot"},{"location":"services/java-springboot/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/java-springboot/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/java_springboot_webapi.yml\" Source: \"./src/services/java/springboot/webapi\" Deployment(s): \"hello-cloud/our-hello-java-springboot-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku","title":" DevOps"},{"location":"services/java-springboot/#deployments","text":"","title":"Deployments"},{"location":"services/java-springboot/#docker","text":"Run as a container The \"hello-cloud/our-hello-java-springboot-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:8080/ . docker run \\ --name = our-hello-java-springboot-webapi \\ --detach \\ --publish = 8080 :8080 \\ ghcr.io/ericis/hello-cloud/our-hello-java-springboot-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-java-springboot-webapi\" image .","title":" Docker"},{"location":"services/java-springboot/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/java-springboot/#amazon-web-services-aws","text":"Prerequisites An AWS account ( this project worked with free infrastructure at the time of its creation ) eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/java-springboot/#microsoft-azure","text":"Prerequisites An Azure account ( this project worked with free infrastructure at the time of its creation ) az CLI java 11 OpenJDK (required to execute ./mvnw commands) Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install dev_tool=maven . It doesn't appear that a gradle-compatible solution is available. Failed attempts have been made to deploy the \".jar\" file independently of ./gradlew or ./mvnw using the Azure CLI e.g. az webapp deploy ... . A future contribution could at least dockerize the maven command, so that tools like docker and podman could be used.) Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":" Microsoft Azure"},{"location":"services/java-springboot/#google-cloud","text":"Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Plugins Google Cloud has documentation for both Gradle and Maven plugins. However, this project focuses on using the gcloud CLI to deploy, allowing the independent choice of either Gradle or Maven. Note that Microsoft Azure support for Java SpringBoot deployments seems to require using their Maven plug-in and does not support Gradle. Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ). Login to your Google Cloud account with the CLI using the command gcloud auth login . Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project. If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources). Once the project is associated with a billing account, re-run the \"gcloud-init\" command above. Install the application with the command make gcloud-install . Check the application logs with the command make gcloud-logs . Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 . Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":" Google Cloud"},{"location":"services/java-springboot/#salesforce-heroku","text":"Prerequisites A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/java/springboot/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the Java buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall","title":" SalesForce Heroku"},{"location":"services/java-springboot/#roadmap","text":"Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( ./gradlew or ./mvnw ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"Roadmap"},{"location":"services/nodejs-expressjs/","text":"Service: NodeJS with ExpressJS Container: \"hello-cloud/our-hello-nodejs-expressjs-webapi\" Source: ./src/services/nodejs/expressjs/webapi/ Runtime: NodeJS Language: JavaScript Framework: ExpressJS Getting started See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally. DevOps Tasks: make Pipeline: \"./.github/workflows/nodejs_expressjs_webapi.yml\" Source: \"./src/services/nodejs/expressjs/webapi\" Deployment(s): \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku Deployments Docker Run as a container The \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:3000/ . docker run \\ --name = our-hello-nodejs-expressjs-webapi \\ --detach \\ --publish = 3000 :3000 \\ ghcr.io/ericis/hello-cloud/our-hello-nodejs-expressjs-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-nodejs-expressjs-webapi\" image . Multi-cloud Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku Amazon Web Services (AWS) Prerequisites An AWS account *this project worked with free infrastructure at the time of its creation eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds. Microsoft Azure Prerequisites An Azure account *this project worked with free infrastructure at the time of its creation az CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall Google Cloud Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Enable Google Cloud Build with the command gcloud services enable cloudbuild.googleapis.com Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Google Cloud account with the CLI using the command gcloud auth login Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project Install the application with the command make gcloud-install If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) Check the application logs with the command make gcloud-logs Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name. SalesForce Heroku Prerequisites A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the node.js buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall Roadmap Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( yarn or npm ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"NodeJS with ExpressJS"},{"location":"services/nodejs-expressjs/#service-nodejs-with-expressjs","text":"Container: \"hello-cloud/our-hello-nodejs-expressjs-webapi\" Source: ./src/services/nodejs/expressjs/webapi/ Runtime: NodeJS Language: JavaScript Framework: ExpressJS","title":"Service: NodeJS with ExpressJS"},{"location":"services/nodejs-expressjs/#getting-started","text":"See \" Docker \" below to run this project as a container The contributor guide has the steps necessary to run this project locally.","title":"Getting started"},{"location":"services/nodejs-expressjs/#devops","text":"Tasks: make Pipeline: \"./.github/workflows/nodejs_expressjs_webapi.yml\" Source: \"./src/services/nodejs/expressjs/webapi\" Deployment(s): \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker container, Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, Google Cloud App Engine, Salesforce Heroku","title":" DevOps"},{"location":"services/nodejs-expressjs/#deployments","text":"","title":"Deployments"},{"location":"services/nodejs-expressjs/#docker","text":"Run as a container The \"hello-cloud/our-hello-nodejs-expressjs-webapi\" docker image is simply the packaged and runnable version of the web service. Run this service with any Open Container Initiative (OCI) compatible runtime, like docker or podman and then browse to http://localhost:3000/ . docker run \\ --name = our-hello-nodejs-expressjs-webapi \\ --detach \\ --publish = 3000 :3000 \\ ghcr.io/ericis/hello-cloud/our-hello-nodejs-expressjs-webapi:latest Using the standard developer make tasks, the service can be containerized and executed with docker , docker-compose or podman . The DevOps pipeline for Continuous Integration (CI) and Deployment (CD) uses the make deploy task to build and deploy the service as a container ( make deploy only supports \"dev_tool=docker\" or \"dev_tool=podman\" ). The GitHub Actions workflow \"./.github/workflows/java_springboot_webapi.yml\" authenticates to the GitHub Container Registry for this repository and pushes (publishes) the \"hello-cloud/our-hello-nodejs-expressjs-webapi\" image .","title":" Docker"},{"location":"services/nodejs-expressjs/#multi-cloud","text":"Commands While each cloud provider below has unique prerequisites and important notes, all of the tasks to deploy to each provider have been abstracted with the following automation tasks. Simply specify the provider as the argument (e.g. make cloud-init cloud=aws ) Initialize with the command make cloud-init cloud=aws|azure|gcloud|heroku Install (deploy) with the command make cloud-install cloud=aws|azure|gcloud|heroku Get the applicaiton logs with the command make cloud-logs cloud=aws|azure|gcloud|heroku Uninstall (delete/destroy) with the command make cloud-uninstall cloud=aws|azure|gcloud|heroku","title":"Multi-cloud"},{"location":"services/nodejs-expressjs/#amazon-web-services-aws","text":"Prerequisites An AWS account *this project worked with free infrastructure at the time of its creation eb CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Run the command make aws-init to create the AWS Elastic Beanstalk Environment. This command may take a few minutes. The eb CLI will prompt you for access credentials. Create a new access key by visiting \"Your Security Credentials\" , expanding \"Access keys\" and creating a new key. Install the application with the command make aws-install . This command may take several seconds. Check the application logs with the command make aws-logs Uninstall and clean up the application deployment with the command make aws-uninstall . This command may take several seconds.","title":" Amazon Web Services (AWS)"},{"location":"services/nodejs-expressjs/#microsoft-azure","text":"Prerequisites An Azure account *this project worked with free infrastructure at the time of its creation az CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Azure account with the CLI using the command az login If you have more than one subscription, first set the default subscription Run the command make azure-init to create the Azure Resource Group Install the application with the command make azure-install Check the application logs with the command make azure-logs Uninstall and clean up the application deployment with the command make azure-uninstall","title":" Microsoft Azure"},{"location":"services/nodejs-expressjs/#google-cloud","text":"Prerequisites An Google Cloud account *this project worked with free infrastructure at the time of its creation Google Cloud SDK Google Cloud Billing Account Enable Google Cloud Build with the command gcloud services enable cloudbuild.googleapis.com Known issues Every attempt has been made to automate the deployment. However, some timing issues have been observed as well as having to manually enable \"Code Build\" and manually associating dynamically created projects with a billing account. Contributions are welcome! Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Google Cloud account with the CLI using the command gcloud auth login Run the command make gcloud-init gcloud_project_name_suffix=001 to create the Google Cloud project Install the application with the command make gcloud-install If the output indicates that billing must be enabled, login to the projects list and associate the newly created project with the appropriate billing account (even if you are using free resources) Check the application logs with the command make gcloud-logs Uninstall and clean up the application deployment with the command make gcloud-uninstall gcloud_project_name_suffix=001 Tip: Project Naming Update the \"gcloud_project_name_suffix\" argument value for gcloud-init and gcloud-uninstall by incrementing the number to ensure a unique project name, or specify a custom unique name by using the argument \"gcloud_project_unique_name\" instead. By default, Google Cloud retains deleted projects for several days, so it is not possible to recreate the same project multiple times within a short period. A future contribution to this project could simply restore a deleted project if it was recently deleted and use the same name.","title":" Google Cloud"},{"location":"services/nodejs-expressjs/#salesforce-heroku","text":"Prerequisites A Heroku account *this project worked with free infrastructure at the time of its creation heroku CLI Commands Open a terminal and navigate to the service project directory (e.g. cd ./src/services/nodejs/expressjs/webapi ) Login to your Heroku account with the CLI using the command heroku login Run the command make heroku-init to create and configure the cloud app including assigning the community monorepo buildpack as well as the node.js buildpack Install the application with the command make heroku-install Check the application logs with the command make heroku-logs Uninstall and clean up the application deployment with the command make heroku-uninstall","title":" SalesForce Heroku"},{"location":"services/nodejs-expressjs/#roadmap","text":"Started Start contributing! Future Deploy to cloud Managed Containers ( refers to a \"run as container\" deployment over full-blown Managed Kubernetes deployment ) \"aws\" \"azure\" \"gcloud\" \"heroku\" Deploy to cloud Managed Kubernetes \"aws\" \"azure\" \"gcloud\" \"heroku\" GitHub Actions workflow to deploy this service to multiple clouds (automation of infrastructure setup and tear-down) Service contracts and auto-generated documentation integrated with MkDocs documentation site Ping / Health endpoint Completed Local \"hello-cloud\" service ( yarn or npm ) Build and run as container ( docker , docker-compose , or podman ) Deploy container to GitHub Container Registry as GitHub Package GitHub Action workflow to build and deploy container to GitHub Container Registry as GitHub Package Deploy to cloud Platform-as-a-Service (PaaS) \"aws\" \"azure\" \"gcloud\" \"heroku\"","title":"Roadmap"}]}